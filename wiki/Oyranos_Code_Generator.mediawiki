== How it works ==
=== Overview ===
The '''oyAPIGenerator''' executable takes 3 arguments as input.
* A directory the templates files using the grantlee format.
* A source directory with all included code from the templates.
* An output directory were all auto-generated code is created.

All are optional, and in an ''in source'' build none of them is actually
used, because they get the default values (respectively):
* ./templates
* ./sources
* ./API_generated

Actually, the '''extract_sources.sh''' shell script is used for convenience.
It cleans the API_generated/ directory, creates the code, and then builds it.
The paths work for an ''in source'' build.

=== The details ===

==== Template system ====

The templates are written in the [http://docs.djangoproject.com/en/dev/topics/templates/ Django template language].
A Django template is a plain text file with some specially formatted '''tags''' and
'''variables'''.
So, a template is just a C or C++ file that contains some extra '''{% tag %}''' and
'''<nowiki>{{ variable }}</nowiki>''' embedded code that is replaced by the code generator.
This is much like ''php'' code is replaced in ''html'' files.
The built in '''tags''' and '''variables''' are
[http://docs.djangoproject.com/en/dev/ref/templates/builtins/ documented here].
The Django template engine is written in python and can be used
[http://docs.djangoproject.com/en/dev/ref/templates/api/#configuring-the-template-system-in-standalone-mode in stand alone mode]. Instead, the ''generator'' is using the
[http://www.grantlee.org/ Grantlee template system], which uses the same template language,
but is written in C++ and depends on [http://qt.nokia.com/ Qt].

So, how is a new source code file auto-generated?
* First the ''generator'' scans the templates/ directory for template files. They have a special file name in the form of file_name.''template''.ext, e.g. oyranos_module.''template''.h
* Then the various template variables are loaded (taken from the source code metadata) and the template is rendered in memory
* A new file is created in API_generated/ with the ''.template.'' removed, e.g. oyranos_module.h

==== Template files ====

There are mainly two kinds of template files.
* A ''base'' template.
* A ''child'' template that extends a ''base'' template. Most templates are ''child'' templates.

The ''child'' templates use the {% extends %} '''tag''', which is how
[http://docs.djangoproject.com/en/dev/topics/templates/#template-inheritance template inheritance] is implemented in the django language. There is a 1-1 relationship between the
class inheritance of the Oyranos object system and the django template inheritance.
For example, that means if ''oyCMMapi10_s'' inherits from ''oyCMMapiFilter_s'',
then ''CMMapi10_s.template.c'' will extend ''CMMapiFilter_s.template.c''. And if 
''oyCMMapiFilter_s'' extends ''oyCMMapi_s'', then ''CMMapiFilters_s.template.h'' will
extend ''CMMapi_s.template.h''.


{| align="center"
|+ style="background-color:#AAAAAA;" | Inheritance Example Table
!  Oyranos Objects !!        !! Template Files
|- align="center"
|  oyStruct_s      || &harr; || Struct_s.template.h
|- align="center"
|                  ||        || &uarr;
|- align="center"
|  &uarr;          ||        || Base_s.h
|- align="center"
|                  ||        || &uarr;
|- align="center"
|  oyCMMapi_s      || &harr; ||  CMMapi_s.template.h
|- align="center"
|  &uarr;          ||        || &uarr;
|- align="center"
|  oyCMMapiFilter_s|| &harr; ||  CMMapiFilter_s.template.h
|- align="center"
|  &uarr;          ||        || &uarr;
|- align="center"
|  oyCMMapi10_s    || &harr; ||  CMMapi10_s.template.h
|}

== Code Organisation ==
=== API_generated/ ===
Not much to say, all the files here are auto-generated from the templates.
Each class is implemented by four files.
;oyClass_s.h
: This is the public header file that exports the class API
;oyClass_s.c
: Here is all the public code implementation.
;oyClass_s_.h
: Private declarations

=== sources/ ===
Here is all the source code that does not need to be inside the templates.
===== <class>.dox =====
This is the Doxygen description for the class, with some additional tags.

<code>
 /** @struct  oyClass_s
  *  @ingroup some_group
  *  @extends oyStruct_s
  *  @brief   Brief description
  *  @internal
  *
  *  Multi line description
  *  @note New templates will not be created automaticly [notemplates]
  *  @note Create templates using "opaque pointer" [opaquepointer]
  *  @note This class holds a list of objects [list]
  *
  *  @version Oyranos: x.x.x
  *  @since   YYYY/MM/DD (Oyranos: x.x.x)
  *  @date    YYYY/MM/DD
  */
</code>

The basic idea is that the ''generator'' needs to know all kinds of information '''(metadata)'''
about the class and these are provided here. Along with the doxygen tags, a few additional
are also needed and are put in the ''@note'' tag.
;[notemplates]
: Each class has a template file for each generated source file.
: At class creation, these are also created automaticly and are read-only.
: When for any reason you want to override some default template block and
: edit the class templates, change their permissions to read-write and
: remove the [notemplates] tag
;[list]
: This tag specifies that the class is a special kind of class, a ''list'' of values. The
: convention is that the class name is in plural ''(ends with s)'' and the list item type
: is the class with the same name without the ''s''. E.g. oyFilterPlugs_s -> oyFilterPlug_s
;[opaquepointer]
: This is an alternative way of the API and should not be used now.

===== <class>.members.h =====
A list of all the class members, e.g. for '''CMMapi6.members.h'''

<code>
  /** oyCMMapi4_s::context_type typic data; e.g. "oyDL" */
  char           * data_type_in;
  /** oyCMMapi7_s::context_type specific data; e.g. "lcCC" */
  char           * data_type_out;
  oyCMMdata_Convert_f oyCMMdata_Convert;
</code>
===== <class>.public.h =====

Here goes code for the oyClass_s.h public header file, e.g. for '''Options.public.h'''
<code>
 typedef oyStruct_s * (*oyStruct_Copy_f ) ( oyStruct_s *, oyPointer );
 typedef int       (*oyStruct_Release_f ) ( oyStruct_s ** );
 typedef oyPointer (*oyStruct_LockCreate_f)(oyStruct_s * obj );
 ...
 extern oyStruct_LockCreate_f   oyStruct_LockCreateFunc_;
 extern oyLockRelease_f         oyLockReleaseFunc_;
 extern oyLock_f                oyLockFunc_;
 extern oyUnLock_f              oyUnLockFunc_;
 ...
</code>

===== <class>.public_methods_declarations.h =====
===== <class>.public_methods_definitions.c =====
===== <class>.private.h =====
===== <class>.private_methods_declarations.h =====
===== <class>.private_methods_definitions.c =====
===== <class>.private_custom_definitions.c =====

=== templates/ ===

==== Files ====

===== Base_s.h =====
===== Base_s.c =====
===== Base_s_.h =====
===== Base_s_.c =====
===== BaseList_s.h =====
===== BaseList_s.c =====
===== BaseList_s_.h =====
===== BaseList_s_.c =====
===== CMakeLists.template.txt =====
===== oyTest.template.h / oyTest.template.cc =====


==== Directories ====

The directories are named by the group name (''@ingroup'' tag) and hold the
template files of the classes that belong to that group.

== How to import a new class ==

The following steps are used.

====1. Initial commit ====
;Directory
: sources/
*(a) cp Class.dox <class>.dox  & edit
*(b) run generator
*(c) Edit <class>.members.h
*(d) cp .private_methods_definitions.c
*(e) run generator
*(f) cp API_generated/oy<class>_s_private_custom_definitions.c  sources/<class>.private_custom_definitions.c
*(g) rm templates/<group>/<class>_s_private_custom_definitions.template.c
*(h) run generator

 ''NOTE'' Skip steps (c) to (h) for list classes.

 ''TODO'' Implement (d) to (e) in the code generator, so that only steps (a) to (c) are needed.

;git short comment
: <nowiki>*</nowiki> Create skeleton files for oyClass_s

==== 2. Import class members like enums,typedefs,... ====
;Search for them in oyranos sources
: grep 'memberof *oy<calss>_s' * -B3
*(a) Private ones in sources/<class>.private.h
*;git short comment
*: [sources] Import oy<class>_s private [enums,typedefs,...]
*(b) Public ones in sources/<class>.public.h
*;git short comment
*: [sources] Import oy<class>_s public [enums,typedefs,...]
*(c) Add proper include files in oyClass_s.h and oyClass_s_.h
*;Find them by trying to compile the object files
*:cd /API_generated/
*:make oyClass_s.o
*:make oyClass_s_.o
*;git short comment
*: [templates] Add include files to oyClass_s.h

==== 3. Implement constructor [oyClass_New] ====
;files:
 sources/<class>.private_custom_definitions.c
;git short comment
: [review] [sources] Implement the constructor for oyClass_s

==== 4. Implement copy constructor [oyClass_Copy] ====
Files:
 sources/<class>.private_custom_definitions.c

;git short comment
: [review] [sources] Implement the copy constructor for oyClass_s

==== 5. Implement destructor [oyClass_Release] ====
sources/
 .private_custom_definitions.c
[review] [sources] Implement the destructor for oyClass_s

==== 6. Import private methods for oyClass_s ====
sources/
 .private_methods_declarations.h
 .private_methods_definitions.c
[sources] Import private methods for oyClass_s

==== 7. Adopt oyClass_s private methods ====
sources/
 .private_methods_declarations.h
 .private_methods_definitions.c
[review] [sources] Adopt oyClass_XXX_() to "hidden struct" interface.

==== 8. Import public methods for oyClass_s ====
sources/
 .public_methods_declarations.h
 .public_methods_definitions.c
[sources] Import public methods for oyClass_s

==== 9. Adopt oyClass_s public methods ====
sources/
 .public_methods_declarations.h
 .public_methods_definitions.c
[review] [sources] Adopt oyClass_XXX() to "hidden struct" interface.